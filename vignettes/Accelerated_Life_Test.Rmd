---
title: "Accelerated Life Testing"
author: "Isaac Michaud"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Accelerated Life Testing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This gives the ALT example for Weaver et al. 2016. It involves computing the preposterior variance of the 10 degree 10 percentile of the failure distribution

```{r}
require(GADGET)
require(rjags)
require(parallel)
set.seed(123)
```

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

$t_\ell = 10$ $t_H = 80$  $N = 165$

Using the Arrhenius transformation 

```{r}
t_low  <- 10
t_high <- 80
N      <- 165 #sample size

arrhenius_transform = function(temp) {
  11605/(temp+273.15)
}

at_low  <- arrhenius_transform(t_low)
at_high <- arrhenius_transform(t_high)

xi_transform <- function(TEMP) { #transform a temp on [10,80] to AT scaled to [0,1] 
  (arrhenius_transform(TEMP) - at_low)/(at_high - at_low)
}

inv_xi <- function(xi) {
  at <- xi*((at_high - at_low)) + at_low
  return((11605/at) - 273.15)
}


t_p <- function(TEMP,p,theta) { #compute pth quantile for TEMP with theta parameters 
  if(is.matrix(theta)) {
    mu            <- theta[,1] + theta[,3]*(xi_transform(TEMP)-0.5)
    result        <- exp(mu + qnorm(p)*theta[,2])
  } else {
    beta_0_star   <- theta[1]
    sigma         <- theta[2]
    beta_1        <- theta[3]
    mu            <- beta_0_star + beta_1*(xi_transform(TEMP)-0.5)
    result        <- exp(mu + qnorm(p)*sigma)
  }
  names(result) <- NULL
  return(result)
}
```

## Prior Distributions

Based on the an analysis of the Device-A data from Meeker 1999 we can assume that the priors are 

```{r}
sample_prior <- function(n) { #prior p1 from Table 1
  beta_0_star <-  rlnorm(n,2.282,0.027)
  sigma       <-  rlnorm(n,0.033,0.140)
  beta_1      <- -rlnorm(n,1.667,0.135)
  return(cbind(beta_0_star,sigma,beta_1))
}
```

prior predictive distribution? not quite it is just the conditional distribution 

```{r}
#--- predictive sampler: f(t|eta,theta) ---# 

sample_design <- function(eta,theta) {
  
  xi_1  <- eta[1]
  xi_2  <- eta[2]
  p     <- eta[3]
  
  tot_n  <- N #165
  n1     <- round(p*tot_n) 
  n2     <- tot_n - n1
  
  beta_0_star <- theta[1] 
  sigma       <- theta[2]
  beta_1      <- theta[3]
  
  xi  <- rep(xi_1,n1)
  obs <- rlnorm(n1, beta_0_star + beta_1*(xi_1-0.5), sigma)
  xi  <- c(xi,rep(xi_2,n2))
  obs <- c(obs, rlnorm(n2, beta_0_star + beta_1*(xi_2-0.5), sigma))
  isCensored <- (obs >= 5000)
  obs[isCensored] <- NA
  return(data.frame(xi = xi, y = obs, isCensored = isCensored*1))
}
```

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Preposterior Variance

Weaver has the it is computed in the following way: $\sum$ of some stuff

In Weaver $A = 1000$ and $B = 1000$, but for computational speed we will use $A=10$ which increases the variability between replicates of the preposterior variance. This can be seen in the resulting estimated nugget effect in the later section. Similar, we reduced $B$ to 500. 


```{r}
# Weaver said that he believed at A=1000 and B=1000
A   <- 10 #outer loop (number of prior draws) 
B   <- 500 #inner loop (number of post draws)
#--- design setup ---#
```


Posterior sampler
```{r}
modelstring = "
model {
for(i in 1:N) {
isCensored[i] ~ dinterval(y[i],5000)
y[i] ~ dlnorm(beta_0 - neg_beta_1*(xi[i]-0.5), 1/sigma^2 )
}

#p1 Priors
beta_0     ~ dlnorm( 2.282, 1/0.027^2 ) 
sigma      ~ dlnorm( 0.033, 1/0.140^2 ) 
neg_beta_1 ~ dlnorm( 1.667, 1/0.135^2 )
}
"

sample_posterior <- function(data) {
  dataList = list(
    y  = data$y,
    xi = data$xi,
    isCensored = data$isCensored,
    N  = length(data$y)
  )
  
  parameters    <- c("beta_0" , "neg_beta_1" , "sigma")  
  adaptSteps    <- 100            # Number of steps to "tune" the samplers.
  burnInSteps   <- 500            # Number of steps to "burn-in" the samplers.
  nChains       <- 1               # Number of chains to run.
  numSavedSteps <- B          # Total number of steps in chains to save.
  thinSteps     <- 5               # Number of steps to "thin" (1=keep every step).
  nPerChain = ceiling( ( numSavedSteps * thinSteps ) / nChains ) # Steps per chain.
  # Create, initialize, and adapt the model:
  jagsModel = jags.model(textConnection(modelstring), data=dataList , 
                          n.chains=nChains , n.adapt=adaptSteps, quiet = TRUE)
  # Burn-in:
  #cat( "Burning in the MCMC chain...\n" )
  update( jagsModel , n.iter=burnInSteps ,progress.bar = "none")
  # The saved MCMC chain:
  #cat( "Sampling final MCMC chain...\n" )
  codaSamples = coda.samples( jagsModel , variable.names=parameters , 
                              n.iter=nPerChain , thin=thinSteps, progress.bar = "none")
  #return(codaSamples)
  post_sample <- as.matrix(codaSamples)
  post_sample <- post_sample[,c(1,3,2)]
  post_sample[,3] <- -post_sample[,3]
  return(post_sample)
}
```

```{r}
#--- design criterion ---#
min_var_temp     <- 10
min_var_quantile <- 0.1

pre_post_var <- function(batch_design,theta,prior_design,prior_response) {
  result  <- rep(0,length(theta[,1]))
  my_func <- function(t) {
    new_data  <- sample_design(batch_design,t)
    new_post  <- sample_posterior(new_data)
    new_t_p   <- t_p(min_var_temp,min_var_quantile,new_post)
    return(var(new_t_p))
  }
  mean(apply(theta,1,my_func))
}
```

Compress the dc to be a function of the design vector only

```{r}
theta  <- sample_prior(A)

dc     <- function(eta) { 
  res <- sqrt(pre_post_var(eta,theta,NULL,NULL))
}
```



The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Running GADGET

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
gadget_experiment <- design_experiment(dc,
                                       lower_bound = c(0,0,0),
                                       upper_bound = c(1,1,1),
                                       init_budget = 30, 
                                       diagnostics = 0, 
                                       optim_budget = 30)
```

### Results

```{r}
par(mfrow=c(2,2))
plot(gadget_experiment$optimization$EQI,type='l',xlab="Iteration",ylab='EQI')
plot(log(gadget_experiment$optimization$Nugget),type='l',xlab="Iteration",ylab="Log of Nugget Effect")
plot(c(10,80),c(10,80),pch=NA, xlab= "Temperature 1", ylab = "Temperature 2")
grid()
for (i in 1:30) {
  des <- gadget_experiment$optimization[i,1:3]
  text(inv_xi(des[1]),inv_xi(des[2]),labels = i)
}
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

# References

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
